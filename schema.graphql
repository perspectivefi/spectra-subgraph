####################
# Enums
####################

enum AssetType {
    UNDERLYING
    IBT
    PT
    YT
    FYT
    LP
    UNKNOWN
}

enum TransactionType {
    DEPOSIT
    WITHDRAW
    CLAIM
    SWAP
}

enum FutureStatus {
    ACTIVE
    PAUSED
    EXPIRED
}

enum AMM {
    CURVE
    UNISWAP_V3
    UNKNOWN
}

enum PriceSource {
    CHAINLINK
    REDSTONE
}

enum FutureState {
    ACTIVE
    PAUSED
    EXPIRED
}

####################
# High level detail entities
####################

"Platform entity to define IBT/FutureVault platform"
# possibility to add new platforms without subgraph update)
type Platform @entity {
    id: ID!
    createdAtTimestamp: BigInt!
    name: String!
    infoUrl: String!
}

"LPTokenDetails entity to define token details in case it is a LP token"
type LPTokenDetails @entity {
    id: ID!
    address: String!
    createdAtTimestamp: BigInt!

    supply: BigDecimal!
    tokens: [Asset!]!
}

"FYTTokenDetails entity to define token details in case it is a FYT token"
type FYTTokenDetails @entity {
    id: ID!
    createdAtTimestamp: BigInt!
    expirationAtTimestamp: BigInt!

    generatedYield: BigDecimal!
    generatedYieldValue: BigDecimal
}

####################
# Registry
####################

type FutureVaultFactory @entity {
    id: ID!
    createdAtTimestamp: BigInt!
    name: String!
    old: FutureVaultFactory
    address: Bytes!
}

####################
# Assets and prices
####################

"Asset entity to index all kind of details of an asset stored in the subgraph"
type Asset @entity {
    id: ID!
    address: Bytes!
    createdAtTimestamp: BigInt!
    name: String!
    symbol: String!
    decimals: Int!
    price: AssetPrice
    type: AssetType!

    "on of the price feeds"
    chainlinkPriceFeed: ChainlinkAggregatorProxy
    "in the case the asset is an IBT we create relation between this IBT and its underlying asset"
    underlying: Asset
    lpTokenDetails: LPTokenDetails
    fytTokenDetails: FYTTokenDetails
}

"AssetPrice entity to assign a price of a token to an Asset entity and its price source"
type AssetPrice @entity {
    id: ID!
    createdAtTimestamp: BigInt!
    value: BigDecimal!
    source: PriceSource
    asset: Asset!
}

"AssetAmount entity to assign an amount of token (in a transaction for instance) to its dollar value and exact asset"
type AssetAmount @entity {
    id: ID!
    createdAtTimestamp: BigInt!
    amount: BigInt!
#    value: BigDecimal!
    asset: Asset!
#    fytTokenDetails: FYTTokenDetails
}

"UserAsset entity to assign and update user's assets balances"
type UserAsset @entity {
    id: ID!
    createdAtTimestamp: BigInt!
    balance: BigInt!
    #    value: BigDecimal!
    "relation to the asset details"
    asset: Asset!
    "relation to the user details"
    user: User!
    #    fytTokenDetails: FYTTokenDetails
}

"ChainlinkAggregatorProxy entity to save information about Chainlink aggregator, mapper should use to fetch the price of an asset"
type ChainlinkAggregatorProxy @entity {
    id: ID!
    "aggregator address"
    aggregator: String!
    asset: Asset!
}

####################
# Futures
####################

"Future entity to index all the future's stats as well as its transactions, managers and other relations"
type Future @entity {
    id: ID!
    address: Bytes!
    createdAtTimestamp: BigInt!
    expirationAtTimestamp: BigInt!
    symbol: String!
    name: String!

    "how big is the fee setup for that future"
    daoFeeRate: BigInt!
    "sum of the collected fees"
    totalFees: BigDecimal!
    "list of all the claims with the details"
    feeClaims: [FeeClaim!]! @derivedFrom(field: "future")

    "sum of the assets (IBTs) allocated into future"
    totalAssets: BigInt!

    state: FutureState!
    underlyingAsset: Asset!
    ibtAsset: Asset!

    transactions: [Transaction!]! @derivedFrom(field: "futureInTransaction")
#
#    ibtToUnderlyingRatio: Value

#    platform: Platform!
#    manager: User!
#    infoUrl: String
#    pools: [Pool!]
}

"FeeClaim entity to list claims triggered on an future by a user"
type FeeClaim @entity {
    id: ID!
    createdAtTimestamp: BigInt!
    amount: BigInt!

    "claimant of the fee"
    feeCollector: User!
    "future used to clam the fee"
    future: Future!
}

####################
# User
####################

"User entity to index all kind of data related to a user of the protocol"
type User @entity {
    id: ID!
    address: Bytes!
    createdAtTimestamp: BigInt!

    collectedFees: [FeeClaim!]! @derivedFrom(field: "feeCollector")
    transactions: [Transaction!]! @derivedFrom(field: "userInTransaction")
    portfolio: [UserAsset!]! @derivedFrom(field: "user")
}

####################
# Transaction
####################

"Transaction entity for all kind of the transactions"
type Transaction @entity {
    id: ID!
    address: Bytes!
    createdAtTimestamp: BigInt!
    block: BigInt!

    gas: BigInt!
    gasPrice: BigInt!

#    fee: BigDecimal!
    type: TransactionType!

    from: Bytes!
    to: Bytes!

    "if there is any future on any side of the transaction to be able to list this future's transactions"
    futureInTransaction: Future
    "if there is any user on any side of the transaction to be able to list this user's transactions"
    userInTransaction: User

    "in case if more than one token was sent"
    amountsIn: [AssetAmount!]!
    "in case if more than one token was received"
    amountsOut: [AssetAmount!]!
}