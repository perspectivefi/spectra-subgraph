####################
# Enums
####################

enum AssetType {
    UNDERLYING
    IBT
    PT
    YT
    FYT
    LP
    UNKNOWN
}

enum TransactionType {
    FUTURE_VAULT_DEPOSIT
    FUTURE_VAULT_WITHDRAW
    AMM_ADD_LIQUIDITY
    AMM_REMOVE_LIQUIDITY
    # if only one coin has been withdrawn
    AMM_REMOVE_LIQUIDITY_ONE
    AMM_EXCHANGE
}

enum FutureStatus {
    ACTIVE
    PAUSED
    EXPIRED
}

enum AMM {
    CURVE
    UNISWAP_V3
    UNKNOWN
}

enum PriceSource {
    CHAINLINK
    REDSTONE
}

enum FutureState {
    ACTIVE
    PAUSED
    EXPIRED
}

####################
# High level detail entities
####################

"Platform entity to define IBT/FutureVault platform"
# possibility to add new platforms without subgraph update)
type Platform @entity {
    id: ID!
    createdAtTimestamp: BigInt!
    name: String!
    infoUrl: String!
}

"FYTTokenDetails entity to define token details in case it is a FYT token"
type FYTTokenDetails @entity {
    id: ID!
    createdAtTimestamp: BigInt!
    expirationAtTimestamp: BigInt!

    generatedYield: BigDecimal!
    generatedYieldValue: BigDecimal
}

"LPTokenDetails entity to define token details in case it is a LP token"
type LPTokenDetails @entity {
    id: ID!
    createdAtTimestamp: BigInt!

    totalSupply: BigInt!

    tokens: [Asset!]!
}

"ValueInTime entity to connect a value with time for history purpose"
type ValueInTime @entity {
    id: ID!
    timestamp: BigInt!
    value: BigInt!
}

####################
# Registry
####################

type FutureVaultFactory @entity {
    id: ID!
    createdAtTimestamp: BigInt!
    name: String!
    old: FutureVaultFactory
    address: Bytes!
}

####################
# Assets and prices
####################

"Asset entity to index all kind of details of an asset stored in the subgraph"
type Asset @entity {
    id: ID!
    address: Bytes!
    createdAtTimestamp: BigInt!
    name: String!
    symbol: String!
    decimals: Int!
    price: AssetPrice
    type: AssetType!

    "on of the price feeds"
    chainlinkPriceFeed: ChainlinkAggregatorProxy

    "in the case the asset is an IBT we create relation between this IBT and its underlying asset"
    underlying: Asset
    fytTokenDetails: FYTTokenDetails
    lpTokenDetails: LPTokenDetails
}

"AssetPrice entity to assign a price of a token to an Asset entity and its price source"
type AssetPrice @entity {
    id: ID!
    createdAtTimestamp: BigInt!
    value: BigDecimal!
    source: PriceSource
    asset: Asset!
}

"AssetAmount entity to assign an amount of token (in a transaction for instance) to its dollar value and exact asset"
type AssetAmount @entity {
    id: ID!
    createdAtTimestamp: BigInt!
    amount: BigInt!
#    value: BigDecimal!
    asset: Asset!
#    fytTokenDetails: FYTTokenDetails
}

"UserAsset entity to assign and update user's assets balances"
type UserAsset @entity {
    id: ID!
    createdAtTimestamp: BigInt!
    balance: BigInt!
    #    value: BigDecimal!
    "relation to the asset details"
    asset: Asset!
    "relation to the user details"
    user: User!
    "if lp position"
    pool: Pool
    #    fytTokenDetails: FYTTokenDetails
}

"ChainlinkAggregatorProxy entity to save information about Chainlink aggregator, mapper should use to fetch the price of an asset"
type ChainlinkAggregatorProxy @entity {
    id: ID!
    "aggregator address"
    aggregator: String!
    asset: Asset!
}

####################
# Futures
####################

"Future entity to index all the future's stats as well as its transactions, managers and other relations"
type Future @entity {
    id: ID!
    address: Bytes!
    createdAtTimestamp: BigInt!
    expirationAtTimestamp: BigInt!
    symbol: String!
    name: String!

    "how big is the fee setup for that future"
    daoFeeRate: BigInt!
    unclaimedFees: BigInt!
    "sum of the collected fees"
    totalCollectedFees: BigInt!
    "list of all the claims with the details"
    feeClaims: [FeeClaim!]! @derivedFrom(field: "future")

    "sum of the assets (IBTs) allocated into future"
    totalAssets: BigInt!

    state: FutureState!
    underlyingAsset: Asset!
    ibtAsset: Asset!

    poolFactory: PoolFactory
    pools: [Pool!]! @derivedFrom(field: "futureVault")

    transactions: [Transaction!]! @derivedFrom(field: "futureInTransaction")

#    ibtToUnderlyingRatio: Value

#    platform: Platform!
#    infoUrl: String
}

"FeeClaim entity to list claims triggered on an future by a user"
type FeeClaim @entity {
    id: ID!
    createdAtTimestamp: BigInt!
    amount: BigInt!

    "claimant of the fee"
    feeCollector: User!
    "future that collector claimed the fees from"
    future: Future
    "pool that collector claimed the fees from"
    pool: Pool
}

####################
# User
####################

"User entity to index all kind of data related to a user of the protocol"
type User @entity {
    id: ID!
    address: Bytes!
    createdAtTimestamp: BigInt!

    collectedFees: [FeeClaim!]! @derivedFrom(field: "feeCollector")
    transactions: [Transaction!]! @derivedFrom(field: "userInTransaction")
    portfolio: [UserAsset!]! @derivedFrom(field: "user")
}

####################
# Transaction
####################

"Transaction entity for all kind of the transactions"
type Transaction @entity {
    id: ID!
    address: Bytes!
    createdAtTimestamp: BigInt!
    block: BigInt!

    gas: BigInt!
    gasPrice: BigInt!

    fee: BigInt
    adminFee: BigInt
#    fee: BigDecimal!
    type: TransactionType!

    "if there is any future on any side of the transaction to be able to list this future's transactions"
    futureInTransaction: Future
    "if there is any user on any side of the transaction to be able to list this user's transactions"
    userInTransaction: User
    "if there is any pool on any side of the transaction to be able to list this pool's transactions"
    poolInTransaction: Pool

    "in case if more than one token was sent"
    amountsIn: [AssetAmount!]!
    "in case if more than one token was received"
    amountsOut: [AssetAmount!]!
}

####################
# AMM
####################

type PoolFactory @entity {
    id: ID!
    address: Bytes!
    createdAtTimestamp: BigInt!

    "it will be Curve by default but we will be able to index others as well"
    ammProvider: AMM!
    feeReceiver: User!
    admin: Bytes!

    future: Future!

    pools: [Pool!]! @derivedFrom(field: "factory")
}

type Pool @entity {
    id: ID!
    address: Bytes!
    createdAtTimestamp: BigInt!

    "pool fees details"
    feeRate: BigInt!
    totalFees: BigInt!
    adminFeeRate: BigInt!
    totalAdminFees: BigInt!
    totalClaimedAdminFees: BigInt!
    feeClaims: [FeeClaim!]! @derivedFrom(field: "pool")
    futureAdminFeeRate: BigInt!
    futureAdminFeeDeadline: BigInt!

    "to be able to follow all the future's pools"
    futureVault: Future!
    "to be able to follow all the pools created by a factory"
    factory: PoolFactory!

    liquidityToken: Asset!
    assets: [AssetAmount!]

    transactionCount: Int!
    transactions: [Transaction!]

    totalLPSupply: BigInt!
    liquidityPositions: [UserAsset!]! @derivedFrom(field: "pool")


#    Asset pricing is not competed at this point
#    valueHistory: [Value!]
}